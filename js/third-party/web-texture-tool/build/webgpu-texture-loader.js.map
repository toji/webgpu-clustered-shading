{
  "version": 3,
  "sources": ["../src/image-loader.js", "../src/worker-loader.js", "../src/texture-format.js", "../src/texture-loader-base.js", "../src/webgpu-mipmap-generator.js", "../src/webgpu-texture-loader.js"],
  "sourcesContent": ["/**\n * @file Loader which handles any image types supported directly by the browser.\n * @module ImageLoader\n */\n\nconst MIME_TYPE_FORMATS = {\n  'image/jpeg': 'rgb8unorm',\n  'image/png': 'rgba8unorm',\n  'image/apng': 'rgba8unorm',\n  'image/gif': 'rgba8unorm',\n  'image/bmp': 'rgb8unorm',\n  'image/webp': 'rgba8unorm',\n  'image/x-icon': 'rgba8unorm',\n  'image/svg+xml': 'rgba8unorm',\n};\nconst IMAGE_BITMAP_SUPPORTED = (typeof createImageBitmap !== 'undefined');\n\n/**\n * Loader which handles any image types supported directly by the browser.\n */\nexport class ImageLoader {\n  /**\n   * Creates a ImageTextureLoader instance.\n   * Should only be called by the WebTextureTool constructor.\n   */\n  constructor() {\n  }\n\n  /**\n   * Which MIME types this loader supports.\n   *\n   * @returns {Array<string>} - An array of the MIME types this loader supports.\n   */\n  static supportedMIMETypes() {\n    return Object.keys(MIME_TYPE_FORMATS);\n  }\n\n  /**\n   * Load a supported file as a texture from the given URL.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {string} url - An absolute URL that the texture file should be loaded from.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromUrl(client, url, options) {\n    let format = MIME_TYPE_FORMATS[options.mimeType];\n\n    if (client.supportedFormatList.indexOf(format) == -1) {\n      // 'rgba8unorm' must be supported by all clients\n      format = 'rgba8unorm';\n    }\n\n    if (IMAGE_BITMAP_SUPPORTED) {\n      const response = await fetch(url);\n      const imageBitmap = await createImageBitmap(await response.blob());\n      return client.fromImageBitmap(imageBitmap, format, options);\n    } else {\n      return new Promise((resolve, reject) => {\n        const imageElement = new Image();\n        imageElement.addEventListener('load', () => {\n          resolve(client.textureFromImageElement(imageElement, format, options));\n        });\n        imageElement.addEventListener('error', function(err) {\n          reject(err);\n        });\n        imageElement.src = url;\n      });\n    };\n  }\n\n  /**\n   * Load a supported file as a texture from the given Blob.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {Blob} blob - Blob containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromBlob(client, blob, options) {\n    let format = MIME_TYPE_FORMATS[blob.type];\n\n    if (client.supportedFormatList.indexOf(format) == -1) {\n      // 'rgba8unorm' must be supported by all clients\n      format = 'rgba8unorm';\n    }\n\n    if (IMAGE_BITMAP_SUPPORTED) {\n      const imageBitmap = await createImageBitmap(blob);\n      return client.fromImageBitmap(imageBitmap, format, options);\n    } else {\n      return new Promise((resolve, reject) => {\n        const imageElement = new Image();\n        imageElement.addEventListener('load', () => {\n          resolve(client.fromImageElement(imageElement, format, options));\n        });\n        imageElement.addEventListener('error', function(err) {\n          reject(err);\n        });\n        const url = window.URL.createObjectURL(blob);\n        imageElement.src = url;\n      });\n    };\n  }\n\n  /**\n   * Load a supported file as a texture from the given ArrayBuffer or ArrayBufferView.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {ArrayBuffer|ArrayBufferView} buffer - Buffer containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromBuffer(client, buffer, options) {\n    const blob = new Blob(buffer, {type: options.mimeType});\n    return this.fromBlob(client, blob, options);\n  }\n\n  /**\n   * Destroy this loader.\n   *\n   * @returns {void}\n   */\n  destroy() {\n    // Nothing to clean up here.\n  }\n}\n", "/**\n * Generic loader which handles texture loading in a worker in order to prevent blocking the main thread.\n *\n * @file Loader that operates a worker script\n * @module WorkerLoader\n */\n\nconst WORKER_DIR = import.meta.url.replace(/[^\\/]*$/, '');\nconst MAX_WORKER_POOL_SIZE = 4;\n\n/**\n * Tracks required data for fulfilling a texture request once it has been transcoded.\n */\nclass PendingTextureRequest {\n  /**\n   * Creates a PendingTextureRequest instance.\n   *\n   * @param {object} client - The WebTextureClient that will upload the transcoded data.\n   * @param {*} options - Options passed during the texture request.\n   * @param {*} resolve - Success callback.\n   * @param {*} reject - Failure callback.\n   */\n  constructor(client, options, resolve, reject) {\n    this.client = client;\n    this.options = options;\n    this.resolve = resolve;\n    this.reject = reject;\n  }\n};\n\nconst pendingTextures = {};\nlet nextPendingTextureId = 1;\n\n/**\n * Called when the worker either finished transcoding a file or encounters an error.\n *\n * @param {object} msg - Message contents from the worker\n * @returns {void}\n */\nfunction onWorkerMessage(msg) {\n  // Find the pending texture associated with the data we just received\n  // from the worker.\n  const pendingTexture = pendingTextures[msg.data.id];\n  if (!pendingTexture) {\n    if (msg.data.error) {\n      console.error(`Texture load failed: ${msg.data.error}`);\n    }\n    console.error(`Invalid pending texture ID: ${msg.data.id}`);\n    return;\n  }\n\n  // Remove the pending texture from the waiting list.\n  delete pendingTextures[msg.data.id];\n\n  // If the worker indicated an error has occured handle it now.\n  if (msg.data.error) {\n    console.error(`Texture load failed: ${msg.data.error}`);\n    pendingTexture.reject(`${msg.data.error}`);\n    return;\n  }\n\n  // Upload the image data returned by the worker.\n  const result = pendingTexture.client.fromTextureData(msg.data, pendingTexture.options);\n  pendingTexture.resolve(result);\n}\n\n/**\n * Loader which handles Basis Universal files.\n */\nexport class WorkerLoader {\n  /**\n   * Creates a WorkerLoader instance.\n   *\n   * @param {string} relativeWorkerPath - Path to the worker script to load, relative to this file.\n   */\n  constructor(relativeWorkerPath) {\n    // Load the worker script.\n    this.workerPath = `${WORKER_DIR}${relativeWorkerPath}`;\n    this.workerPool = [];\n    this.nextWorker = 0;\n    this.outstandingRequests = 0;\n\n    this.addWorker();\n  }\n\n  addWorker() {\n    const worker = new Worker(this.workerPath);\n    worker.onmessage = (msg) => {\n      onWorkerMessage(msg);\n      this.outstandingRequests--;\n    };\n\n    this.workerPool.push(worker);\n    return worker;\n  }\n\n  selectWorker() {\n    this.outstandingRequests++;\n    if (this.outstandingRequests >= this.workerPool.length && this.workerPool.length < MAX_WORKER_POOL_SIZE) {\n      return this.addWorker();\n    }\n    return this.workerPool[this.nextWorker++ % this.workerPool.length];\n  }\n\n  /**\n   * Load a supported file as a texture from the given URL.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {string} url - An absolute URL that the texture file should be loaded from.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromUrl(client, url, options) {\n    const pendingTextureId = nextPendingTextureId++;\n\n    this.selectWorker().postMessage({\n      id: pendingTextureId,\n      url: url,\n      supportedFormats: client.supportedFormats(),\n      mipmaps: options.mipmaps,\n      extension: options.extension,\n    });\n\n    return new Promise((resolve, reject) => {\n      pendingTextures[pendingTextureId] = new PendingTextureRequest(client, options, resolve, reject);\n    });\n  }\n\n  /**\n   * Load a supported file as a texture from the given Blob.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {Blob} blob - Blob containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromBlob(client, blob, options) {\n    const buffer = await blob.arrayBuffer();\n    return this.fromBuffer(client, buffer, options);\n  }\n\n  /**\n   * Load a supported file as a texture from the given ArrayBuffer or ArrayBufferView.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   * @param {ArrayBuffer|ArrayBufferView} buffer - Buffer containing the texture file data.\n   * @param {object} options - Options for how the loaded texture should be handled.\n   * @returns {Promise<module:WebTextureLoader.WebTextureResult>} - The WebTextureResult obtained from passing the\n   * parsed file data to the client.\n   */\n  async fromBuffer(client, buffer, options) {\n    const pendingTextureId = nextPendingTextureId++;\n\n    this.selectWorker().postMessage({\n      id: pendingTextureId,\n      buffer: buffer,\n      supportedFormats: client.supportedFormats(),\n      mipmaps: options.mipmaps,\n      extension: options.extension,\n    });\n\n    return new Promise((resolve, reject) => {\n      pendingTextures[pendingTextureId] = new PendingTextureRequest(client, options, resolve, reject);\n    });\n  }\n\n  /**\n   * Destroy this loader.\n   * Terminates the worker and rejects any outstanding textures. The loader is unusable after calling destroy().\n   *\n   * @returns {void}\n   */\n  destroy() {\n    if (this.worker) {\n      this.worker.terminate();\n\n      const destroyedError = new Error('Texture loader was destroyed.');\n      for (const pendingTexture of pendingTextures) {\n        pendingTexture.reject(destroyedError);\n      }\n    }\n  }\n}\n", "// For access to WebGL enums without a context.\nconst GL = WebGLRenderingContext;\n\n/**\n * Texture Format\n *\n * @typedef {string} WebTextureFormat\n */\n\n// Additional format data used by Web Texture Tool, based off WebGPU formats.\n// WebGL equivalents given where possible.\nexport const WebTextureFormat = {\n  // Uncompressed formats\n  'rgb8unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGB, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8051}, // RGB8\n  },\n  'rgba8unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8058}, // RGBA8\n  },\n  'rgb8unorm-srgb': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8C43}, // SRGB8_ALPHA8\n  },\n  'rgba8unorm-srgb': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_BYTE, sizedFormat: 0x8C43}, // SRGB8_ALPHA8\n  },\n  'rgb565unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGB, type: GL.UNSIGNED_SHORT_5_6_5, sizedFormat: GL.RGB565},\n  },\n  'rgba4unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_SHORT_4_4_4_4, sizedFormat: GL.RGBA4},\n  },\n  'rgba5551unorm': {\n    canGenerateMipmaps: true,\n    gl: {format: GL.RGBA, type: GL.UNSIGNED_SHORT_5_5_5_1, sizedFormat: GL.RGB5_A1},\n  },\n\n  'bgra8unorm': {canGenerateMipmaps: true}, // No WebGL equivalent\n  'bgra8unorm-srgb': {canGenerateMipmaps: true}, // No WebGL equivalent\n\n  // Compressed formats\n  // WebGL enums from http://www.khronos.org/registry/webgl/extensions/\n  'bc1-rgb-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x83F0}, // COMPRESSED_RGB_S3TC_DXT1_EXT\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n  'bc2-rgba-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x83F2}, // COMPRESSED_RGBA_S3TC_DXT3_EXT\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'bc3-rgba-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x83F3}, // COMPRESSED_RGBA_S3TC_DXT5_EXT\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'bc7-rgba-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x8E8C}, // COMPRESSED_RGBA_BPTC_UNORM_EXT\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'etc1-rgb-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x8D64}, // COMPRESSED_RGB_ETC1_WEBGL\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n  'etc2-rgba8unorm': {\n    gl: {texStorage: true, sizedFormat: 0x9278}, // COMPRESSED_RGBA8_ETC2_EAC\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'astc-4x4-rgba-unorm': {\n    gl: {texStorage: true, sizedFormat: 0x93B0}, // COMPRESSED_RGBA_ASTC_4x4_KHR\n    compressed: {blockBytes: 16, blockWidth: 4, blockHeight: 4},\n  },\n  'pvrtc1-4bpp-rgb-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x8C00}, // COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n  'pvrtc1-4bpp-rgba-unorm': {\n    gl: {texStorage: false, sizedFormat: 0x8C02}, // COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n    compressed: {blockBytes: 8, blockWidth: 4, blockHeight: 4},\n  },\n};\n", "/**\n * This library offers a unified way of loading textures for both WebGL and WebGPU from various file formats, and in all\n * cases attempts to handle the loading as efficently as possible. Every effort made to prevent texture loading from\n * blocking the main thread, since that can often be one of the primary causes of jank during page startup or while\n * streaming in new assets.\n *\n * @file Library for loading various image sources as textures for WebGL or WebGPU\n * @module TextureLoaderBase\n */\n\nimport {ImageLoader} from './image-loader.js';\nimport {WorkerLoader} from './worker-loader.js';\nimport {WebTextureFormat} from './texture-format.js';\n\n/**\n * Texture result from calling one of the WebTextureTool methods\n *\n * @property {(module:External.WebGLTexture|module:External.GPUTexture)} texture - WebGL or WebGPU texture object.\n * @property {number} width of mip level 0 in pixels.\n * @property {number} height of mip level 0 in pixels.\n * @property {number} depth of mip level 0 in pixels.\n * @property {number} mipLevels - Number of mip levels the texture contains.\n * @property {WebTextureFormat} format - Format of the texture.\n */\nexport class WebTextureResult {\n  /**\n   * Create an instance of a WebTextureResult.\n   *\n   * @param {(module:External.WebGLTexture|module:External.GPUTexture)} texture - WebGL or WebGPU texture object.\n   * @param {number} width of mip level 0 in pixels.\n   * @param {number} height of mip level 0 in pixels.\n   * @param {number} depth of mip level 0 in pixels.\n   * @param {number} mipLevels - Number of mip levels the texture contains.\n   * @param {WebTextureFormat} format - Format of the texture.\n   */\n  constructor(texture, description = {}) {\n    this.texture = texture;\n    this.width = description.width || 1;\n    this.height = description.height || 1;\n    this.depth = description.depth || 1;\n    this.mipLevels = description.mipLevels || 1;\n    this.format = description.format || 'rgba8unorm';\n    this.type = description.type || '2d';\n  }\n\n  get glFormat() {\n    const texProperties = WebTextureFormat[this.format];\n    return texProperties.gl.format  || null;\n  }\n\n  get glSizedFormat() {\n    const texProperties = WebTextureFormat[this.format];\n    return texProperties.gl.sizedFormat;\n  }\n\n  get glTarget() {\n    switch (this.type) {\n      case 'cube':\n        return GL.TEXTURE_CUBE_MAP;\n      case '2d':\n      default:\n        return GL.TEXTURE_2D;\n    }\n  }\n}\n\nexport class WebTextureData {\n  constructor(format, width, height, imageData = null, imageDataOptions = {}) {\n    this.format = format;\n    this.width = Math.max(1, width);\n    this.height = Math.max(1, height);\n    this.levels = [];\n\n    // Optionally, data for the first image's first mip level can be passed to the constructor to handle simple cases.\n    if (imageData) {\n      this.getLevel(0).setSlice(0, imageData, imageDataOptions);\n    }\n  }\n\n  getLevel(index, options = {}) {\n    let level = this.levels[index];\n    if (!level) {\n      level = new WebTextureLevelData(this, index, options);\n      this.levels[index] = level;\n    }\n    return level;\n  }\n}\n\nclass WebTextureLevelData {\n  constructor(textureData, levelIndex, options) {\n    this.textureData = textureData;\n    this.levelIndex = levelIndex;\n    this.width = Math.max(1, options.width || this.textureData.width >> levelIndex);\n    this.height = Math.max(1, options.height || this.textureData.height >> levelIndex);\n    this.slices = [];\n  }\n\n  setSlice(index, bufferOrTypedArray, options = {}) {\n    if (this.slices[index] != undefined) {\n      throw new Error('Cannot define an image slice twice.');\n    }\n\n    let byteOffset = options.byteOffset || 0;\n    let byteLength = options.byteLength || 0;\n\n    let buffer;\n    if (bufferOrTypedArray instanceof ArrayBuffer) {\n      buffer = bufferOrTypedArray;\n      if (!byteLength) {\n        byteLength = buffer.byteLength - byteOffset;\n      }\n    } else {\n      buffer = bufferOrTypedArray.buffer;\n      if (!byteLength) {\n        byteLength = bufferOrTypedArray.byteLength - byteOffset;\n      }\n      byteOffset += bufferOrTypedArray.byteOffset;\n    }\n\n    this.slices[index] = {\n      buffer,\n      byteOffset,\n      byteLength,\n    };\n  }\n}\n\n/**\n * Associates a set of extensions with a specifc loader.\n */\nclass ExtensionHandler {\n  /**\n   * Creates an ExtensionHandler.\n   *\n   * @param {Array<string>} extensions - List of extensions that this loader can handle.\n   * @param {Function} callback - Callback which returns an instance of the loader.\n   */\n  constructor(mimeTypes, callback) {\n    this.mimeTypes = mimeTypes;\n    this.callback = callback;\n    this.loader = null;\n  }\n\n  /**\n   * Gets the loader associated with this extension set. Creates an instance by calling the callback if one hasn't been\n   * instantiated previously.\n   *\n   * @returns {object} Texture Loader instance.\n   */\n  getLoader() {\n    if (!this.loader) {\n      this.loader = this.callback();\n    }\n    return this.loader;\n  }\n}\n\nconst EXTENSION_MIME_TYPES = {\n  jpg: 'image/jpeg',\n  jpeg: 'image/jpeg',\n  png: 'image/png',\n  apng: 'image/apng',\n  gif: 'image/gif',\n  bmp: 'image/bmp',\n  webp: 'image/webp',\n  ico: 'image/x-icon',\n  cur: 'image/x-icon',\n  svg: 'image/svg+xml',\n  basis: 'image/basis',\n  ktx: 'image/ktx',\n  ktx2: 'image/ktx2',\n  dds: 'image/vnd.ms-dds',\n};\n\nconst EXTENSION_HANDLERS = [\n  new ExtensionHandler(ImageLoader.supportedMIMETypes(), () => new ImageLoader()),\n  new ExtensionHandler(['image/basis'], () => new WorkerLoader('workers/basis/basis-worker.js')),\n  new ExtensionHandler(['image/ktx', 'image/ktx2'], () => new WorkerLoader('workers/ktx/ktx-worker.js')),\n  new ExtensionHandler(['image/vnd.ms-dds'], () => new WorkerLoader('workers/dds-worker.js')),\n];\n\nconst CLIENT = Symbol('wtt/WebTextureClient');\nconst LOADERS = Symbol('wtt/WebTextureLoaders');\n\nconst TMP_ANCHOR = document.createElement('a');\nconst IMAGE_BITMAP_SUPPORTED = (typeof createImageBitmap !== 'undefined');\n\nconst DEFAULT_URL_OPTIONS = {\n  mimeType: null,\n  mipmaps: true,\n  colorSpace: 'default',\n};\n\nfunction getMimeTypeLoader(wtt, mimeType) {\n  if (!mimeType) {\n    throw new Error('A valid MIME type must be specified.');\n  }\n\n  let typeHandler = wtt[LOADERS][mimeType];\n  if (!typeHandler) {\n    typeHandler = wtt[LOADERS]['*'];\n  }\n\n  // Get the appropriate loader for the extension. Will instantiate the loader instance the first time it's\n  // used.\n  const loader = typeHandler.getLoader();\n  if (!loader) {\n    throw new Error(`Failed to get loader for MIME type \"${mimeType}\"`);\n  }\n  return loader;\n}\n\n/**\n * Base texture loader class.\n * Must not be used directly, create an instance of WebGLTextureLoader or WebGPUTextureLoader instead.\n */\nexport class TextureLoaderBase {\n  /**\n   * WebTextureTool constructor. Must not be called by applications directly.\n   * Create an instance of WebGLTextureTool or WebGPUTextureTool as needed instead.\n   *\n   * @param {object} client - The WebTextureClient which will upload the texture data to the GPU.\n   */\n  constructor(client) {\n    this[CLIENT] = client;\n    this[LOADERS] = {};\n\n    // Map every available extension to it's associated handler\n    for (const extensionHandler of EXTENSION_HANDLERS) {\n      for (const mimeType of extensionHandler.mimeTypes) {\n        this[LOADERS][mimeType] = extensionHandler;\n      }\n    }\n\n    // Register one last \"fallback\" extension. Anything that we receive that has an unrecognized extension will try to\n    // load with the ImageTextureLoader.\n    this[LOADERS]['*'] = EXTENSION_HANDLERS[0];\n  }\n\n  /** Loads a texture from the given URL\n   *\n   * @param {string} url - URL of the file to load.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async fromUrl(url, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    // Use this to resolve to a full URL.\n    TMP_ANCHOR.href = url;\n\n    // If an explicit extension wasn't provided, examine the URL to determine one.\n    if (!options.mimeType) {\n      // Isolate just the pathname from the given URL, then split the extension off of that.\n      const extIndex = TMP_ANCHOR.pathname.lastIndexOf('.');\n      const extension = extIndex > -1 ? TMP_ANCHOR.pathname.substring(extIndex+1).toLowerCase() : '*';\n      options.mimeType = EXTENSION_MIME_TYPES[extension];\n    }\n\n    const loader = getMimeTypeLoader(this, options.mimeType);\n    return loader.fromUrl(this[CLIENT], TMP_ANCHOR.href, options);\n  }\n\n  /** Loads a texture from the given blob\n   *\n   * @param {Blob} blob - Blob containing the texture file data.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async fromBlob(blob, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    const loader = getMimeTypeLoader(this, blob.type);\n    return loader.fromBlob(this[CLIENT], blob, options);\n  }\n\n  /** Loads a texture from the given blob\n   *\n   * @param {ArrayBuffer|ArrayBufferView} buffer - Buffer containing the texture file data.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async fromBuffer(buffer, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    if (!options.mimeType && options.filename) {\n      const extIndex = options.filename.lastIndexOf('.');\n      const extension = extIndex > -1 ? options.filename.substring(extIndex+1).toLowerCase() : null;\n      options.mimeType = EXTENSION_MIME_TYPES[extension];\n    }\n\n    const loader = getMimeTypeLoader(this, options.mimeType);\n    return loader.fromBuffer(this[CLIENT], buffer, options);\n  }\n\n  /** Loads a texture from the given image element.\n   *\n   * @param {Element} element - HTML element (img, canvas, video, etc) to load as a texture.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async fromElement(element, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n\n    if (!IMAGE_BITMAP_SUPPORTED) {\n      return this[CLIENT].textureFromImageElement(element, 'rgba8unorm', options);\n    }\n    const imageBitmap = await createImageBitmap(element);\n    return this[CLIENT].fromImageBitmap(imageBitmap, 'rgba8unorm', options);\n  }\n\n  /** Loads a texture from the given image bitmap.\n   *\n   * @param {ImageBitmap} imageBitmap - Image bitmap to load as a texture.\n   * @param {object} textureOptions - Options for how the loaded texture should be handled.\n   * @returns {Promise<WebTextureResult>} - Promise which resolves to the completed WebTextureResult.\n   */\n  async fromImageBitmap(imageBitmap, textureOptions) {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const options = Object.assign({}, DEFAULT_URL_OPTIONS, textureOptions);\n    return this[CLIENT].fromImageBitmap(imageBitmap, 'rgba8unorm', options);\n  }\n\n  /**\n   * Creates a 1x1 texture with the specified color.\n   *\n   * @param {number} r - Red channel value\n   * @param {number} g - Green channel value\n   * @param {number} b - Blue channel value\n   * @param {number} [a=1.0] - Alpha channel value\n   * @param {WebTextureFormat} [format='rgba8unorm'] - Format to create the texture with\n   * @returns {WebTextureResult} - Completed WebTextureResult\n   */\n  fromColor(r, g, b, a = 1.0, format = 'rgba8unorm') {\n    if (!this[CLIENT]) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n    if (format != 'rgba8unorm' && format != 'rgba8unorm-srgb') {\n      throw new Error('createTextureFromColor only supports \"rgba8unorm\" and \"rgba8unorm-srgb\" formats');\n    }\n    const data = new Uint8Array([r * 255, g * 255, b * 255, a * 255]);\n    return this[CLIENT].fromTextureData(new WebTextureData(format, 1, 1, data), false);\n  }\n\n  /**\n   * Sets whether or not compressed formats should be loaded.\n   * If `false` and a compressed texture can be transcoded to an uncompressed format it will be, otherwise it will be\n   * rejected.\n   *\n   * @param {boolean} value - `true` if compressed formats should be loaded.\n   */\n  set allowCompressedFormats(value) {\n    this[CLIENT].allowCompressedFormats = !!value;\n  }\n\n  /**\n   * Returns whether or not compressed formats should be loaded.\n   *\n   * @returns {boolean} `true` if compressed formats should be loaded.\n   */\n  get allowCompressedFormats() {\n    return this[CLIENT].allowCompressedFormats;\n  }\n\n  /**\n   * Destroys the texture tool and stops any in-progress texture loads that have been started.\n   *\n   * @returns {void}\n   */\n  destroy() {\n    if (this[CLIENT]) {\n      this[CLIENT].destroy();\n      this[CLIENT] = null;\n\n      // TODO: Should this happen?\n      // Would have to make sure every instance had it's own copies of the loaders.\n      // Shut down every loader that this class has initialized.\n      /*\n      for (const extensionHandler of this[LOADERS]) { // Doesn't work\n        if (extensionHandler.loader) {\n          extensionHandler.loader.destroy();\n          extensionHandler.loader = null;\n        }\n      }\n      */\n    }\n  }\n}\n", "export class WebGPUMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({minFilter: 'linear'});\n    // We'll need a new pipeline for every texture format used.\n    this.pipelines = {};\n  }\n\n  getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      // Shaders are shared between all pipelines, so only create once.\n      if (!this.mipmapVertexShaderModule || !this.mipmapFragmentShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: `\n            var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(\n              vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),\n              vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));\n\n            struct VertexOutput {\n              [[builtin(position)]] position : vec4<f32>;\n              [[location(0)]] texCoord : vec2<f32>;\n            };\n\n            [[stage(vertex)]]\n            fn vertexMain([[builtin(vertex_index)]] vertexIndex : u32) -> VertexOutput {\n              var output : VertexOutput;\n              output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n              output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n              return output;\n            }\n\n            [[binding(0), group(0)]] var imgSampler : sampler;\n            [[binding(1), group(0)]] var img : texture_2d<f32>;\n\n            [[stage(fragment)]]\n            fn fragmentMain([[location(0)]] texCoord : vec2<f32>) -> [[location(0)]] vec4<f32> {\n              return textureSample(img, imgSampler, texCoord);\n            }\n          `,\n        });\n      }\n\n      pipeline = this.device.createRenderPipeline({\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: 'vertexMain',\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: 'fragmentMain',\n          targets: [{format}],\n        },\n        primitive: {\n          topology: 'triangle-strip',\n          stripIndexFormat: 'uint32',\n        },\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   *\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @param {object} textureDescriptor - GPUTextureDescriptor the texture was created with.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture, textureDescriptor) {\n    // TODO: Does this need to handle sRGB formats differently?\n    const pipeline = this.getMipmapPipeline(textureDescriptor.format);\n\n    if (textureDescriptor.dimension == '3d' || textureDescriptor.dimension == '1d') {\n      throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n    }\n\n    let mipTexture = texture;\n    const arrayLayerCount = textureDescriptor.size.depthOrArrayLayers || 1; // Only valid for 2D textures.\n\n    // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.\n    const renderToSource = textureDescriptor.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n      // texture, since we already have the top level.\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(textureDescriptor.size.width / 2),\n          height: Math.ceil(textureDescriptor.size.height / 2),\n          depthOrArrayLayers: arrayLayerCount,\n        },\n        format: textureDescriptor.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: textureDescriptor.mipLevelCount - 1,\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n\n    const commandEncoder = this.device.createCommandEncoder({});\n    // TODO: Consider making this static.\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: '2d',\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1,\n      });\n\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < textureDescriptor.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: '2d',\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1,\n        });\n\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            loadValue: [0, 0, 0, 0],\n            storeOp: 'store'\n          }],\n        });\n\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler,\n          }, {\n            binding: 1,\n            resource: srcView,\n          }],\n        });\n\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(4, 1, 0, 0);\n        passEncoder.endPass();\n\n        srcView = dstView;\n      }\n    }\n\n    // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n    // to the source.\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(textureDescriptor.size.width / 2),\n        height: Math.ceil(textureDescriptor.size.height / 2),\n        depthOrArrayLayers: arrayLayerCount,\n      };\n\n      for (let i = 1; i < textureDescriptor.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i-1,\n        }, {\n          texture: texture,\n          mipLevel: i,\n        }, mipLevelSize);\n\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n\n    this.device.queue.submit([commandEncoder.finish()]);\n\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n\n    return texture;\n  }\n}\n", "/**\n * Supports loading textures for WebGPU, as well as providing common utilities that are not part of the core WebGPU API\n * such as mipmap generation.\n *\n * @file WebGPU client for the Web Texture Loader\n * @module WebGPUTextureLoader\n */\n\nimport {TextureLoaderBase, WebTextureResult} from './texture-loader-base.js';\nimport {WebTextureFormat} from './texture-format.js';\nimport {WebGPUMipmapGenerator} from './webgpu-mipmap-generator.js';\n\nconst IMAGE_BITMAP_SUPPORTED = (typeof createImageBitmap !== 'undefined');\n\nconst EXTENSION_FORMATS = {\n  'texture-compression-bc': [\n    'bc1-rgba-unorm',\n    'bc1-rgba-unorm-srgb',\n    'bc2-rgba-unorm',\n    'bc2-rgba-unorm-srgb',\n    'bc3-rgba-unorm',\n    'bc3-rgba-unorm-srgb',\n    'bc7-rgba-unorm',\n    'bc7-rgba-unorm-srgb',\n  ],\n};\n\nconst LINEAR_TO_SRGB_FORMATS = {\n  'rgb8unorm': 'rgb8unorm-srgb',\n  'rgba8unorm': 'rgba8unorm-srgb',\n  'bgra8unorm': 'bgra8unorm-srgb',\n  'bc1-rgba-unorm': 'bc1-rgba-unorm-srgb',\n  'bc2-rgba-unorm': 'bc2-rgba-unorm-srgb',\n  'bc3-rgba-unorm': 'bc3-rgba-unorm-srgb',\n  'bc7-rgba-unorm': 'bc7-rgba-unorm-srgb',\n};\n\nconst SRGB_TO_LINEAR_FORMATS = {\n  'rgb8unorm-srgb': 'rgb8unorm',\n  'rgba8unorm-srgb': 'rgba8unorm',\n  'bgra8unorm-srgb': 'bgra8unorm',\n  'bc1-rgba-unorm-srgb': 'bc1-rgba-unorm',\n  'bc2-rgba-unorm-srgb': 'bc2-rgba-unorm',\n  'bc3-rgba-unorm-srgb': 'bc3-rgba-unorm',\n  'bc7-rgba-unorm-srgb': 'bc7-rgba-unorm',\n};\n\nfunction formatForColorSpace(format, colorSpace) {\n  switch (colorSpace) {\n    case 'sRGB':\n      return LINEAR_TO_SRGB_FORMATS[format] || format;\n    case 'linear':\n      return SRGB_TO_LINEAR_FORMATS[format] || format;\n    default:\n      return format;\n  }\n}\n\n/**\n * Determines the number of mip levels needed for a full mip chain given the width and height of texture level 0.\n *\n * @param {number} width of texture level 0.\n * @param {number} height of texture level 0.\n * @returns {number} Ideal number of mip levels.\n */\nfunction calculateMipLevels(width, height) {\n  return Math.floor(Math.log2(Math.max(width, height))) + 1;\n}\n\n/**\n * Variant of TextureLoaderBase which produces WebGPU textures.\n */\nexport class WebGPUTextureLoader extends TextureLoaderBase {\n  /**\n   * Creates a WebTextureTool instance which produces WebGPU textures.\n   *\n   * @param {module:External.GPUDevice} device - WebGPU device to create textures with.\n   * @param {object} toolOptions - Options to initialize this WebTextureTool instance with.\n   */\n  constructor(device, toolOptions) {\n    super(new WebGPUTextureClient(device), toolOptions);\n  }\n}\n\n/**\n * Texture Client that interfaces with WebGPU.\n */\nclass WebGPUTextureClient {\n  /**\n   * Creates a WebTextureClient instance which uses WebGPU.\n   * Should not be called outside of the WebGLTextureTool constructor.\n   *\n   * @param {module:External.GPUDevice} device - WebGPU device to use.\n   */\n  constructor(device) {\n    this.device = device;\n    this.allowCompressedFormats = true;\n\n    this.uncompressedFormatList = [\n      'rgba8unorm',\n      'rgba8unorm-srgb',\n      'bgra8unorm',\n      'bgra8unorm-srgb',\n    ];\n\n    this.supportedFormatList = [\n      'rgba8unorm',\n      'rgba8unorm-srgb',\n      'bgra8unorm',\n      'bgra8unorm-srgb',\n    ];\n\n    // Add any other formats that are exposed by WebGPU features.\n    const featureList = device.features;\n    if (featureList) { // Firefox seems to not support reporting features yet.\n      for (const feature in EXTENSION_FORMATS) {\n        if (featureList.has(feature)) {\n          const formats = EXTENSION_FORMATS[feature];\n          this.supportedFormatList.push(...formats);\n        }\n      }\n    }\n\n    this.mipmapGenerator = new WebGPUMipmapGenerator(device);\n  }\n\n  /**\n   * Returns a list of the WebTextureFormats that this client can support.\n   *\n   * @returns {Array<module:WebTextureTool.WebTextureFormat>} - List of supported WebTextureFormats.\n   */\n  supportedFormats() {\n    if (this.allowCompressedFormats) {\n      return this.supportedFormatList;\n    } else {\n      return this.uncompressedFormatList;\n    }\n  }\n\n  /**\n   * Creates a GPUTexture from the given ImageBitmap.\n   *\n   * @param {module:External.ImageBitmap} imageBitmap - ImageBitmap source for the texture.\n   * @param {module:WebTextureTool.WebTextureFormat} format - Format to store the texture as on the GPU. Must be an\n   * uncompressed format.\n   * @param {boolean} generateMipmaps - True if mipmaps are desired.\n   * @returns {module:WebTextureTool.WebTextureResult} - Completed texture and metadata.\n   */\n  async fromImageBitmap(imageBitmap, format, options) {\n    if (!this.device) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n    const generateMipmaps = options.mipmaps;\n    const mipLevelCount = generateMipmaps ? calculateMipLevels(imageBitmap.width, imageBitmap.height) : 1;\n\n    const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT;\n\n    const textureDescriptor = {\n      size: {width: imageBitmap.width, height: imageBitmap.height},\n      format: formatForColorSpace(format, options.colorSpace),\n      usage,\n      mipLevelCount,\n    };\n    const texture = this.device.createTexture(textureDescriptor);\n\n    this.device.queue.copyExternalImageToTexture({source: imageBitmap}, {texture}, textureDescriptor.size);\n\n    if (generateMipmaps) {\n      this.mipmapGenerator.generateMipmap(texture, textureDescriptor);\n    }\n\n    return new WebTextureResult(texture, {\n      width: imageBitmap.width,\n      height: imageBitmap.height,\n      mipLevels: mipLevelCount,\n      format: format,\n    });\n  }\n\n  /**\n   * Creates a GPUTexture from the given HTMLImageElement.\n   * Note that WebGPU cannot consume image elements directly, so this method will attempt to create an ImageBitmap and\n   * pass that to textureFromImageBitmap instead.\n   *\n   * @param {module:External.HTMLImageElement} image - image source for the texture.\n   * @param {module:WebTextureTool.WebTextureFormat} format - Format to store the texture as on the GPU. Must be an\n   * uncompressed format.\n   * @param {boolean} generateMipmaps - True if mipmaps are desired.\n   * @returns {module:WebTextureTool.WebTextureResult} - Completed texture and metadata.\n   */\n  async fromImageElement(image, format, options) {\n    if (!this.device) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n    if (!IMAGE_BITMAP_SUPPORTED) {\n      throw new Error('Must support ImageBitmap to use WebGPU. (How did you even get to this error?)');\n    }\n    const imageBitmap = await createImageBitmap(image);\n    return this.textureFromImageBitmap(imageBitmap, format, options);\n  }\n\n  /**\n   * Creates a GPUTexture from the given texture level data.\n   *\n   * @param {module:WebTextureTool.WebTextureData} textureData - Object containing data and layout for each image and\n   * mip level of the texture.\n   * @param {boolean} generateMipmaps - True if mipmaps generation is desired. Only applies if a single level is given\n   * and the texture format is renderable.\n   * @returns {module:WebTextureTool.WebTextureResult} - Completed texture and metadata.\n   */\n  fromTextureData(textureData, options) {\n    if (!this.device) {\n      throw new Error('Cannot create new textures after object has been destroyed.');\n    }\n\n    const wtFormat = WebTextureFormat[textureData.format];\n    if (!wtFormat) {\n      throw new Error(`Unknown format \"${textureData.format}\"`);\n    }\n\n    const blockInfo = wtFormat.compressed || {blockBytes: 4, blockWidth: 1, blockHeight: 1};\n    const generateMipmaps = options.mipmaps && wtFormat.canGenerateMipmaps;\n\n    const mipLevelCount = textureData.levels.length > 1 ? textureData.levels.length :\n                            (generateMipmaps ? calculateMipLevels(textureData.width, textureData.height) : 1);\n\n    const usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n\n    const textureDescriptor = {\n      size: {\n        width: Math.ceil(textureData.width / blockInfo.blockWidth) * blockInfo.blockWidth,\n        height: Math.ceil(textureData.height / blockInfo.blockHeight) * blockInfo.blockHeight,\n        depthOrArrayLayers: textureData.depth,\n      },\n      format: formatForColorSpace(textureData.format, options.colorSpace),\n      usage,\n      mipLevelCount: mipLevelCount,\n    };\n    const texture = this.device.createTexture(textureDescriptor);\n\n    for (const mipLevel of textureData.levels) {\n      const bytesPerRow = Math.ceil(mipLevel.width / blockInfo.blockWidth) * blockInfo.blockBytes;\n\n      for (const slice of mipLevel.slices) {\n        // TODO: It may be more efficient to upload the mip levels to a buffer and copy to the texture, but this makes\n        // the code significantly simpler and avoids an alignment issue I was seeing previously, so for now we'll take\n        // the easy route.\n        this.device.queue.writeTexture(\n            {\n              texture: texture,\n              mipLevel: mipLevel.levelIndex,\n              origin: {z: slice.sliceIndex},\n            },\n            slice.buffer,\n            {\n              offset: slice.byteOffset,\n              bytesPerRow,\n            },\n            { // Copy width and height must be a multiple of the format block size;\n              width: Math.ceil(mipLevel.width / blockInfo.blockWidth) * blockInfo.blockWidth,\n              height: Math.ceil(mipLevel.height / blockInfo.blockHeight) * blockInfo.blockHeight,\n            });\n      }\n    }\n\n    if (generateMipmaps) {\n      this.mipmapGenerator.generateMipmap(texture, textureDescriptor);\n    }\n\n    return new WebTextureResult(texture, {\n      width: textureData.width,\n      height: textureData.height,\n      depth: textureData.depth,\n      mipLevels: mipLevelCount,\n      format: textureData.format,\n      type: textureData.type,\n    });\n  }\n\n  /**\n   * Destroy this client.\n   * The client is unusable after calling destroy().\n   *\n   * @returns {void}\n   */\n  destroy() {\n    this.device = null;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
